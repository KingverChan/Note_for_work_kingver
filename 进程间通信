进程间通信（IPC）介绍
共享内存：
 ![Image text](../Screenshots/sheard memory.png)
进程A 将数据放在物理内存中， 进程B从物理内存总读取数据：


https://www.cnblogs.com/tsh292278/p/10681470.html
Q1：A 如申请内存，如何释放内存
所需头文件：
  #include <sys/ipc.h>
  #include <sys/shm.h>
  int shmget(key_t key, size_t size,int shmflg);
功能：  创建或打开一块共享内存区。
参数：
  key：进程间通信键值，ftok() 的返回值。
  size：该共享存储段的长度(字节)。
  shmflg：标识函数的行为及共享内存的权限，其取值如下：
  IPC_CREAT：如果不存在就创建
  IPC_EXCL： 如果已经存在则返回失败
  位或权限位：共享内存位或权限位后可以设置共享内存的访问权限，格式和 open() 函数的 mode_t 一样（open() 的使用请点此链接），但可执行权限未使用。

返回值：
  成功：共享内存标识符。
  失败：-1。

A 进程通过调用shmget（Shared Memory GET，获取共享内存）来分配一个共享内存块。
B 进程可以通过指定同一个键以获取对同一个共享内存块的访问。
其它程序也可能挑选了同样的特定值作为自己分配共享内存的键值，从而产生冲突。
用特殊常量IPC_PRIVATE作为键值可以保证系统建立一个全新的共享内存块。
该函数的第二个参数指定了所申请的内存块的大小。
因为这些内存块是以页面为单位进行分配的，实际分配的内存块大小将被扩大到页面大小的整数倍。
第三个参数是一组标志，通过特定常量的按位或操作来shmget。

Q2: B 如何找到该物理内存


Q3: B 如何读取


Q4: 如何防止 A 写的时候 B 不读， B 读的时候 A 不写。
  因为系统内核没有对访问共享内存进行同步，您必须提供自己的同步措施。
  例如，在数据被写入之前不允许进程从共享内存中读取信息、不允许两个进程同时向同一个共享内存地址写入数据等。
  解决这些问题的常用方法是通过使用信号量进行同步。(如何使用信号量同步，待完善)
